
BootloaderX.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000812  00060000  00060000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .BOOT         00000044  00060812  00060812  00000866  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000008aa  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 000001a0  00000000  00000000  000008e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00002809  00000000  00000000  00000a80  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000861  00000000  00000000  00003289  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000011ce  00000000  00000000  00003aea  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000004b8  00000000  00000000  00004cb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000d96  00000000  00000000  00005170  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000018d6  00000000  00000000  00005f06  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000178  00000000  00000000  000077e0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00060000 <__vectors>:
   60000:	fd c0       	rjmp	.+506    	; 0x601fc <__ctors_end>
   60002:	00 00       	nop
   60004:	0d c1       	rjmp	.+538    	; 0x60220 <__bad_interrupt>
   60006:	00 00       	nop
   60008:	0b c1       	rjmp	.+534    	; 0x60220 <__bad_interrupt>
   6000a:	00 00       	nop
   6000c:	09 c1       	rjmp	.+530    	; 0x60220 <__bad_interrupt>
   6000e:	00 00       	nop
   60010:	07 c1       	rjmp	.+526    	; 0x60220 <__bad_interrupt>
   60012:	00 00       	nop
   60014:	05 c1       	rjmp	.+522    	; 0x60220 <__bad_interrupt>
   60016:	00 00       	nop
   60018:	03 c1       	rjmp	.+518    	; 0x60220 <__bad_interrupt>
   6001a:	00 00       	nop
   6001c:	01 c1       	rjmp	.+514    	; 0x60220 <__bad_interrupt>
   6001e:	00 00       	nop
   60020:	ff c0       	rjmp	.+510    	; 0x60220 <__bad_interrupt>
   60022:	00 00       	nop
   60024:	fd c0       	rjmp	.+506    	; 0x60220 <__bad_interrupt>
   60026:	00 00       	nop
   60028:	fb c0       	rjmp	.+502    	; 0x60220 <__bad_interrupt>
   6002a:	00 00       	nop
   6002c:	f9 c0       	rjmp	.+498    	; 0x60220 <__bad_interrupt>
   6002e:	00 00       	nop
   60030:	f7 c0       	rjmp	.+494    	; 0x60220 <__bad_interrupt>
   60032:	00 00       	nop
   60034:	f5 c0       	rjmp	.+490    	; 0x60220 <__bad_interrupt>
   60036:	00 00       	nop
   60038:	f3 c0       	rjmp	.+486    	; 0x60220 <__bad_interrupt>
   6003a:	00 00       	nop
   6003c:	f1 c0       	rjmp	.+482    	; 0x60220 <__bad_interrupt>
   6003e:	00 00       	nop
   60040:	ef c0       	rjmp	.+478    	; 0x60220 <__bad_interrupt>
   60042:	00 00       	nop
   60044:	ed c0       	rjmp	.+474    	; 0x60220 <__bad_interrupt>
   60046:	00 00       	nop
   60048:	eb c0       	rjmp	.+470    	; 0x60220 <__bad_interrupt>
   6004a:	00 00       	nop
   6004c:	e9 c0       	rjmp	.+466    	; 0x60220 <__bad_interrupt>
   6004e:	00 00       	nop
   60050:	e7 c0       	rjmp	.+462    	; 0x60220 <__bad_interrupt>
   60052:	00 00       	nop
   60054:	e5 c0       	rjmp	.+458    	; 0x60220 <__bad_interrupt>
   60056:	00 00       	nop
   60058:	e3 c0       	rjmp	.+454    	; 0x60220 <__bad_interrupt>
   6005a:	00 00       	nop
   6005c:	e1 c0       	rjmp	.+450    	; 0x60220 <__bad_interrupt>
   6005e:	00 00       	nop
   60060:	df c0       	rjmp	.+446    	; 0x60220 <__bad_interrupt>
   60062:	00 00       	nop
   60064:	dd c0       	rjmp	.+442    	; 0x60220 <__bad_interrupt>
   60066:	00 00       	nop
   60068:	db c0       	rjmp	.+438    	; 0x60220 <__bad_interrupt>
   6006a:	00 00       	nop
   6006c:	d9 c0       	rjmp	.+434    	; 0x60220 <__bad_interrupt>
   6006e:	00 00       	nop
   60070:	d7 c0       	rjmp	.+430    	; 0x60220 <__bad_interrupt>
   60072:	00 00       	nop
   60074:	d5 c0       	rjmp	.+426    	; 0x60220 <__bad_interrupt>
   60076:	00 00       	nop
   60078:	d3 c0       	rjmp	.+422    	; 0x60220 <__bad_interrupt>
   6007a:	00 00       	nop
   6007c:	d1 c0       	rjmp	.+418    	; 0x60220 <__bad_interrupt>
   6007e:	00 00       	nop
   60080:	cf c0       	rjmp	.+414    	; 0x60220 <__bad_interrupt>
   60082:	00 00       	nop
   60084:	cd c0       	rjmp	.+410    	; 0x60220 <__bad_interrupt>
   60086:	00 00       	nop
   60088:	cb c0       	rjmp	.+406    	; 0x60220 <__bad_interrupt>
   6008a:	00 00       	nop
   6008c:	c9 c0       	rjmp	.+402    	; 0x60220 <__bad_interrupt>
   6008e:	00 00       	nop
   60090:	c7 c0       	rjmp	.+398    	; 0x60220 <__bad_interrupt>
   60092:	00 00       	nop
   60094:	c5 c0       	rjmp	.+394    	; 0x60220 <__bad_interrupt>
   60096:	00 00       	nop
   60098:	c3 c0       	rjmp	.+390    	; 0x60220 <__bad_interrupt>
   6009a:	00 00       	nop
   6009c:	c1 c0       	rjmp	.+386    	; 0x60220 <__bad_interrupt>
   6009e:	00 00       	nop
   600a0:	bf c0       	rjmp	.+382    	; 0x60220 <__bad_interrupt>
   600a2:	00 00       	nop
   600a4:	bd c0       	rjmp	.+378    	; 0x60220 <__bad_interrupt>
   600a6:	00 00       	nop
   600a8:	bb c0       	rjmp	.+374    	; 0x60220 <__bad_interrupt>
   600aa:	00 00       	nop
   600ac:	b9 c0       	rjmp	.+370    	; 0x60220 <__bad_interrupt>
   600ae:	00 00       	nop
   600b0:	b7 c0       	rjmp	.+366    	; 0x60220 <__bad_interrupt>
   600b2:	00 00       	nop
   600b4:	b5 c0       	rjmp	.+362    	; 0x60220 <__bad_interrupt>
   600b6:	00 00       	nop
   600b8:	b3 c0       	rjmp	.+358    	; 0x60220 <__bad_interrupt>
   600ba:	00 00       	nop
   600bc:	b1 c0       	rjmp	.+354    	; 0x60220 <__bad_interrupt>
   600be:	00 00       	nop
   600c0:	af c0       	rjmp	.+350    	; 0x60220 <__bad_interrupt>
   600c2:	00 00       	nop
   600c4:	ad c0       	rjmp	.+346    	; 0x60220 <__bad_interrupt>
   600c6:	00 00       	nop
   600c8:	ab c0       	rjmp	.+342    	; 0x60220 <__bad_interrupt>
   600ca:	00 00       	nop
   600cc:	a9 c0       	rjmp	.+338    	; 0x60220 <__bad_interrupt>
   600ce:	00 00       	nop
   600d0:	a7 c0       	rjmp	.+334    	; 0x60220 <__bad_interrupt>
   600d2:	00 00       	nop
   600d4:	a5 c0       	rjmp	.+330    	; 0x60220 <__bad_interrupt>
   600d6:	00 00       	nop
   600d8:	a3 c0       	rjmp	.+326    	; 0x60220 <__bad_interrupt>
   600da:	00 00       	nop
   600dc:	a1 c0       	rjmp	.+322    	; 0x60220 <__bad_interrupt>
   600de:	00 00       	nop
   600e0:	9f c0       	rjmp	.+318    	; 0x60220 <__bad_interrupt>
   600e2:	00 00       	nop
   600e4:	9d c0       	rjmp	.+314    	; 0x60220 <__bad_interrupt>
   600e6:	00 00       	nop
   600e8:	9b c0       	rjmp	.+310    	; 0x60220 <__bad_interrupt>
   600ea:	00 00       	nop
   600ec:	99 c0       	rjmp	.+306    	; 0x60220 <__bad_interrupt>
   600ee:	00 00       	nop
   600f0:	97 c0       	rjmp	.+302    	; 0x60220 <__bad_interrupt>
   600f2:	00 00       	nop
   600f4:	95 c0       	rjmp	.+298    	; 0x60220 <__bad_interrupt>
   600f6:	00 00       	nop
   600f8:	93 c0       	rjmp	.+294    	; 0x60220 <__bad_interrupt>
   600fa:	00 00       	nop
   600fc:	91 c0       	rjmp	.+290    	; 0x60220 <__bad_interrupt>
   600fe:	00 00       	nop
   60100:	8f c0       	rjmp	.+286    	; 0x60220 <__bad_interrupt>
   60102:	00 00       	nop
   60104:	8d c0       	rjmp	.+282    	; 0x60220 <__bad_interrupt>
   60106:	00 00       	nop
   60108:	8b c0       	rjmp	.+278    	; 0x60220 <__bad_interrupt>
   6010a:	00 00       	nop
   6010c:	89 c0       	rjmp	.+274    	; 0x60220 <__bad_interrupt>
   6010e:	00 00       	nop
   60110:	87 c0       	rjmp	.+270    	; 0x60220 <__bad_interrupt>
   60112:	00 00       	nop
   60114:	85 c0       	rjmp	.+266    	; 0x60220 <__bad_interrupt>
   60116:	00 00       	nop
   60118:	83 c0       	rjmp	.+262    	; 0x60220 <__bad_interrupt>
   6011a:	00 00       	nop
   6011c:	81 c0       	rjmp	.+258    	; 0x60220 <__bad_interrupt>
   6011e:	00 00       	nop
   60120:	7f c0       	rjmp	.+254    	; 0x60220 <__bad_interrupt>
   60122:	00 00       	nop
   60124:	7d c0       	rjmp	.+250    	; 0x60220 <__bad_interrupt>
   60126:	00 00       	nop
   60128:	7b c0       	rjmp	.+246    	; 0x60220 <__bad_interrupt>
   6012a:	00 00       	nop
   6012c:	79 c0       	rjmp	.+242    	; 0x60220 <__bad_interrupt>
   6012e:	00 00       	nop
   60130:	77 c0       	rjmp	.+238    	; 0x60220 <__bad_interrupt>
   60132:	00 00       	nop
   60134:	75 c0       	rjmp	.+234    	; 0x60220 <__bad_interrupt>
   60136:	00 00       	nop
   60138:	73 c0       	rjmp	.+230    	; 0x60220 <__bad_interrupt>
   6013a:	00 00       	nop
   6013c:	71 c0       	rjmp	.+226    	; 0x60220 <__bad_interrupt>
   6013e:	00 00       	nop
   60140:	6f c0       	rjmp	.+222    	; 0x60220 <__bad_interrupt>
   60142:	00 00       	nop
   60144:	6d c0       	rjmp	.+218    	; 0x60220 <__bad_interrupt>
   60146:	00 00       	nop
   60148:	6b c0       	rjmp	.+214    	; 0x60220 <__bad_interrupt>
   6014a:	00 00       	nop
   6014c:	69 c0       	rjmp	.+210    	; 0x60220 <__bad_interrupt>
   6014e:	00 00       	nop
   60150:	67 c0       	rjmp	.+206    	; 0x60220 <__bad_interrupt>
   60152:	00 00       	nop
   60154:	65 c0       	rjmp	.+202    	; 0x60220 <__bad_interrupt>
   60156:	00 00       	nop
   60158:	63 c0       	rjmp	.+198    	; 0x60220 <__bad_interrupt>
   6015a:	00 00       	nop
   6015c:	61 c0       	rjmp	.+194    	; 0x60220 <__bad_interrupt>
   6015e:	00 00       	nop
   60160:	5f c0       	rjmp	.+190    	; 0x60220 <__bad_interrupt>
   60162:	00 00       	nop
   60164:	5d c0       	rjmp	.+186    	; 0x60220 <__bad_interrupt>
   60166:	00 00       	nop
   60168:	5b c0       	rjmp	.+182    	; 0x60220 <__bad_interrupt>
   6016a:	00 00       	nop
   6016c:	59 c0       	rjmp	.+178    	; 0x60220 <__bad_interrupt>
   6016e:	00 00       	nop
   60170:	57 c0       	rjmp	.+174    	; 0x60220 <__bad_interrupt>
   60172:	00 00       	nop
   60174:	55 c0       	rjmp	.+170    	; 0x60220 <__bad_interrupt>
   60176:	00 00       	nop
   60178:	53 c0       	rjmp	.+166    	; 0x60220 <__bad_interrupt>
   6017a:	00 00       	nop
   6017c:	51 c0       	rjmp	.+162    	; 0x60220 <__bad_interrupt>
   6017e:	00 00       	nop
   60180:	4f c0       	rjmp	.+158    	; 0x60220 <__bad_interrupt>
   60182:	00 00       	nop
   60184:	4d c0       	rjmp	.+154    	; 0x60220 <__bad_interrupt>
   60186:	00 00       	nop
   60188:	4b c0       	rjmp	.+150    	; 0x60220 <__bad_interrupt>
   6018a:	00 00       	nop
   6018c:	49 c0       	rjmp	.+146    	; 0x60220 <__bad_interrupt>
   6018e:	00 00       	nop
   60190:	47 c0       	rjmp	.+142    	; 0x60220 <__bad_interrupt>
   60192:	00 00       	nop
   60194:	45 c0       	rjmp	.+138    	; 0x60220 <__bad_interrupt>
   60196:	00 00       	nop
   60198:	43 c0       	rjmp	.+134    	; 0x60220 <__bad_interrupt>
   6019a:	00 00       	nop
   6019c:	41 c0       	rjmp	.+130    	; 0x60220 <__bad_interrupt>
   6019e:	00 00       	nop
   601a0:	3f c0       	rjmp	.+126    	; 0x60220 <__bad_interrupt>
   601a2:	00 00       	nop
   601a4:	3d c0       	rjmp	.+122    	; 0x60220 <__bad_interrupt>
   601a6:	00 00       	nop
   601a8:	3b c0       	rjmp	.+118    	; 0x60220 <__bad_interrupt>
   601aa:	00 00       	nop
   601ac:	39 c0       	rjmp	.+114    	; 0x60220 <__bad_interrupt>
   601ae:	00 00       	nop
   601b0:	37 c0       	rjmp	.+110    	; 0x60220 <__bad_interrupt>
   601b2:	00 00       	nop
   601b4:	35 c0       	rjmp	.+106    	; 0x60220 <__bad_interrupt>
   601b6:	00 00       	nop
   601b8:	33 c0       	rjmp	.+102    	; 0x60220 <__bad_interrupt>
   601ba:	00 00       	nop
   601bc:	31 c0       	rjmp	.+98     	; 0x60220 <__bad_interrupt>
   601be:	00 00       	nop
   601c0:	2f c0       	rjmp	.+94     	; 0x60220 <__bad_interrupt>
   601c2:	00 00       	nop
   601c4:	2d c0       	rjmp	.+90     	; 0x60220 <__bad_interrupt>
   601c6:	00 00       	nop
   601c8:	2b c0       	rjmp	.+86     	; 0x60220 <__bad_interrupt>
   601ca:	00 00       	nop
   601cc:	29 c0       	rjmp	.+82     	; 0x60220 <__bad_interrupt>
   601ce:	00 00       	nop
   601d0:	27 c0       	rjmp	.+78     	; 0x60220 <__bad_interrupt>
   601d2:	00 00       	nop
   601d4:	25 c0       	rjmp	.+74     	; 0x60220 <__bad_interrupt>
   601d6:	00 00       	nop
   601d8:	23 c0       	rjmp	.+70     	; 0x60220 <__bad_interrupt>
   601da:	00 00       	nop
   601dc:	21 c0       	rjmp	.+66     	; 0x60220 <__bad_interrupt>
   601de:	00 00       	nop
   601e0:	1f c0       	rjmp	.+62     	; 0x60220 <__bad_interrupt>
   601e2:	00 00       	nop
   601e4:	1d c0       	rjmp	.+58     	; 0x60220 <__bad_interrupt>
   601e6:	00 00       	nop
   601e8:	1b c0       	rjmp	.+54     	; 0x60220 <__bad_interrupt>
   601ea:	00 00       	nop
   601ec:	19 c0       	rjmp	.+50     	; 0x60220 <__bad_interrupt>
   601ee:	00 00       	nop
   601f0:	17 c0       	rjmp	.+46     	; 0x60220 <__bad_interrupt>
   601f2:	00 00       	nop
   601f4:	15 c0       	rjmp	.+42     	; 0x60220 <__bad_interrupt>
   601f6:	00 00       	nop
   601f8:	13 c0       	rjmp	.+38     	; 0x60220 <__bad_interrupt>
	...

000601fc <__ctors_end>:
   601fc:	11 24       	eor	r1, r1
   601fe:	1f be       	out	0x3f, r1	; 63
   60200:	cf ef       	ldi	r28, 0xFF	; 255
   60202:	cd bf       	out	0x3d, r28	; 61
   60204:	df e9       	ldi	r29, 0x9F	; 159
   60206:	de bf       	out	0x3e, r29	; 62
   60208:	03 e0       	ldi	r16, 0x03	; 3
   6020a:	0c bf       	out	0x3c, r16	; 60

0006020c <__do_clear_bss>:
   6020c:	20 e2       	ldi	r18, 0x20	; 32
   6020e:	a0 e0       	ldi	r26, 0x00	; 0
   60210:	b0 e2       	ldi	r27, 0x20	; 32
   60212:	01 c0       	rjmp	.+2      	; 0x60216 <.do_clear_bss_start>

00060214 <.do_clear_bss_loop>:
   60214:	1d 92       	st	X+, r1

00060216 <.do_clear_bss_start>:
   60216:	a0 30       	cpi	r26, 0x00	; 0
   60218:	b2 07       	cpc	r27, r18
   6021a:	e1 f7       	brne	.-8      	; 0x60214 <.do_clear_bss_loop>
   6021c:	0c d1       	rcall	.+536    	; 0x60436 <main>
   6021e:	f7 c2       	rjmp	.+1518   	; 0x6080e <_exit>

00060220 <__bad_interrupt>:
   60220:	ef ce       	rjmp	.-546    	; 0x60000 <__vectors>

00060222 <ccp_write_io>:

	PUBLIC_FUNCTION(ccp_write_io)

#if defined(__GNUC__)

	out     RAMPZ, r1               // Reset bits 23:16 of Z
   60222:	1b be       	out	0x3b, r1	; 59
	movw    r30, r24                // Load addr into Z
   60224:	fc 01       	movw	r30, r24
	ldi     r18, CCP_IOREG          // Load magic CCP value
   60226:	28 ed       	ldi	r18, 0xD8	; 216
	out     CCP, r18                // Start CCP handshake
   60228:	24 bf       	out	0x34, r18	; 52
	st      Z, r22                  // Write value to I/O register
   6022a:	60 83       	st	Z, r22
	ret                             // Return to caller
   6022c:	08 95       	ret

0006022e <PMIC_SetVectorLocationToBoot>:
   /*Set the correct settings and store critical registers before NVM-workaround*/
#ifdef WORKAROUND
   Prepare_to_Sleep();
#endif
   /*Assembly "function" to load word into flash buffer*/
  nvm_flash_load_word_to_buffer(address, word);
   6022e:	e0 ea       	ldi	r30, 0xA0	; 160
   60230:	f0 e0       	ldi	r31, 0x00	; 0
   60232:	82 81       	ldd	r24, Z+2	; 0x02
   60234:	80 64       	ori	r24, 0x40	; 64
   60236:	98 ed       	ldi	r25, 0xD8	; 216
   60238:	94 bf       	out	0x34, r25	; 52
   6023a:	82 83       	std	Z+2, r24	; 0x02
   6023c:	08 95       	ret

0006023e <PMIC_SetVectorLocationToApplication>:
   6023e:	e0 ea       	ldi	r30, 0xA0	; 160
   60240:	f0 e0       	ldi	r31, 0x00	; 0
   60242:	82 81       	ldd	r24, Z+2	; 0x02
   60244:	8f 7b       	andi	r24, 0xBF	; 191
   60246:	98 ed       	ldi	r25, 0xD8	; 216
   60248:	94 bf       	out	0x34, r25	; 52
   6024a:	82 83       	std	Z+2, r24	; 0x02
   6024c:	08 95       	ret

0006024e <EraseApplicationPage>:
   6024e:	e0 ec       	ldi	r30, 0xC0	; 192
   60250:	f1 e0       	ldi	r31, 0x01	; 1
   60252:	27 85       	ldd	r18, Z+15	; 0x0f
   60254:	22 23       	and	r18, r18
   60256:	ec f3       	brlt	.-6      	; 0x60252 <EraseApplicationPage+0x4>
   60258:	42 e2       	ldi	r20, 0x22	; 34
   6025a:	db c2       	rjmp	.+1462   	; 0x60812 <_etext>
   6025c:	08 95       	ret

0006025e <EraseWriteApplicationPage>:
   6025e:	e0 ec       	ldi	r30, 0xC0	; 192
   60260:	f1 e0       	ldi	r31, 0x01	; 1
   60262:	27 85       	ldd	r18, Z+15	; 0x0f
   60264:	22 23       	and	r18, r18
   60266:	ec f3       	brlt	.-6      	; 0x60262 <EraseWriteApplicationPage+0x4>
   60268:	45 e2       	ldi	r20, 0x25	; 37
   6026a:	d3 c2       	rjmp	.+1446   	; 0x60812 <_etext>
   6026c:	08 95       	ret

0006026e <EraseFlashBuffer>:
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   6026e:	e0 ec       	ldi	r30, 0xC0	; 192
   60270:	f1 e0       	ldi	r31, 0x01	; 1
   60272:	87 85       	ldd	r24, Z+15	; 0x0f
   60274:	88 23       	and	r24, r24
   60276:	ec f3       	brlt	.-6      	; 0x60272 <EraseFlashBuffer+0x4>
 *
 */
static inline void nvm_flash_flush_buffer(void)
{
	nvm_wait_until_ready();
	nvm_common_spm(0, NVM_CMD_ERASE_FLASH_BUFFER_gc);
   60278:	46 e2       	ldi	r20, 0x26	; 38
   6027a:	60 e0       	ldi	r22, 0x00	; 0
   6027c:	70 e0       	ldi	r23, 0x00	; 0
   6027e:	cb 01       	movw	r24, r22
   60280:	c8 c2       	rjmp	.+1424   	; 0x60812 <_etext>
   60282:	08 95       	ret

00060284 <BlockLoad>:


#ifndef REMOVE_BLOCK_SUPPORT

unsigned char BlockLoad(unsigned int size, unsigned char mem, ADDR_T address)
{   
   60284:	4f 92       	push	r4
   60286:	5f 92       	push	r5
   60288:	6f 92       	push	r6
   6028a:	7f 92       	push	r7
   6028c:	8f 92       	push	r8
   6028e:	9f 92       	push	r9
   60290:	af 92       	push	r10
   60292:	bf 92       	push	r11
   60294:	cf 92       	push	r12
   60296:	df 92       	push	r13
   60298:	ef 92       	push	r14
   6029a:	ff 92       	push	r15
   6029c:	0f 93       	push	r16
   6029e:	1f 93       	push	r17
   602a0:	cf 93       	push	r28
   602a2:	df 93       	push	r29
   602a4:	cd b7       	in	r28, 0x3d	; 61
   602a6:	de b7       	in	r29, 0x3e	; 62
   602a8:	d2 50       	subi	r29, 0x02	; 2
   602aa:	cd bf       	out	0x3d, r28	; 61
   602ac:	de bf       	out	0x3e, r29	; 62
   602ae:	6c 01       	movw	r12, r24
   602b0:	49 01       	movw	r8, r18
   602b2:	5a 01       	movw	r10, r20
   unsigned int data;    
   ADDR_T tempaddress;
   
   // EEPROM memory type.
   if(mem=='E')
   602b4:	65 34       	cpi	r22, 0x45	; 69
   602b6:	d1 f5       	brne	.+116    	; 0x6032c <BlockLoad+0xa8>
   {
      unsigned char value;
      unsigned char buffer[BLOCKSIZE];
      
      
	  nvm_eeprom_flush_buffer();
   602b8:	13 d2       	rcall	.+1062   	; 0x606e0 <nvm_eeprom_flush_buffer>
 *  IO mapped access is now enabled.
 */
static inline void eeprom_disable_mapping(void)
{
#if !XMEGA_E
	NVM_CTRLB = NVM_CTRLB & ~NVM_EEMAPEN_bm;
   602ba:	ec ec       	ldi	r30, 0xCC	; 204
   602bc:	f1 e0       	ldi	r31, 0x01	; 1
   602be:	80 81       	ld	r24, Z
   602c0:	87 7f       	andi	r24, 0xF7	; 247
   602c2:	80 83       	st	Z, r24
      // disable mapping of EEPROM into data space (enable IO mapped access)
      
	  eeprom_disable_mapping();
      
      // Fill buffer first, as EEPROM is too slow to copy with UART speed 
      for(tempaddress=0;tempaddress<size;tempaddress++){
   602c4:	e1 2c       	mov	r14, r1
   602c6:	f1 2c       	mov	r15, r1
   602c8:	c1 14       	cp	r12, r1
   602ca:	d1 04       	cpc	r13, r1
   602cc:	e1 04       	cpc	r14, r1
   602ce:	f1 04       	cpc	r15, r1
   602d0:	59 f1       	breq	.+86     	; 0x60328 <BlockLoad+0xa4>
   602d2:	8e 01       	movw	r16, r28
   602d4:	0f 5f       	subi	r16, 0xFF	; 255
   602d6:	1f 4f       	sbci	r17, 0xFF	; 255
   602d8:	41 2c       	mov	r4, r1
   602da:	51 2c       	mov	r5, r1
   602dc:	32 01       	movw	r6, r4
	 buffer[tempaddress] = recchar();
   602de:	8f d2       	rcall	.+1310   	; 0x607fe <recchar>
   602e0:	f8 01       	movw	r30, r16
   602e2:	81 93       	st	Z+, r24
   602e4:	8f 01       	movw	r16, r30
      // disable mapping of EEPROM into data space (enable IO mapped access)
      
	  eeprom_disable_mapping();
      
      // Fill buffer first, as EEPROM is too slow to copy with UART speed 
      for(tempaddress=0;tempaddress<size;tempaddress++){
   602e6:	ff ef       	ldi	r31, 0xFF	; 255
   602e8:	4f 1a       	sub	r4, r31
   602ea:	5f 0a       	sbc	r5, r31
   602ec:	6f 0a       	sbc	r6, r31
   602ee:	7f 0a       	sbc	r7, r31
   602f0:	4c 14       	cp	r4, r12
   602f2:	5d 04       	cpc	r5, r13
   602f4:	6e 04       	cpc	r6, r14
   602f6:	7f 04       	cpc	r7, r15
   602f8:	91 f7       	brne	.-28     	; 0x602de <BlockLoad+0x5a>
   602fa:	8e 01       	movw	r16, r28
   602fc:	0f 5f       	subi	r16, 0xFF	; 255
   602fe:	1f 4f       	sbci	r17, 0xFF	; 255
   60300:	41 2c       	mov	r4, r1
   60302:	51 2c       	mov	r5, r1
   60304:	32 01       	movw	r6, r4
      }
      
      // Then program the EEPROM 
      for( tempaddress=0; tempaddress < size; tempaddress++)
      {
	 	 value = buffer[tempaddress];
   60306:	f8 01       	movw	r30, r16
   60308:	61 91       	ld	r22, Z+
   6030a:	8f 01       	movw	r16, r30
   6030c:	c2 01       	movw	r24, r4
   6030e:	88 0d       	add	r24, r8
   60310:	99 1d       	adc	r25, r9
	 
	 
	 nvm_eeprom_write_byte(address,value);
   60312:	09 d2       	rcall	.+1042   	; 0x60726 <nvm_eeprom_write_byte>
      for(tempaddress=0;tempaddress<size;tempaddress++){
	 buffer[tempaddress] = recchar();
      }
      
      // Then program the EEPROM 
      for( tempaddress=0; tempaddress < size; tempaddress++)
   60314:	ff ef       	ldi	r31, 0xFF	; 255
   60316:	4f 1a       	sub	r4, r31
   60318:	5f 0a       	sbc	r5, r31
   6031a:	6f 0a       	sbc	r6, r31
   6031c:	7f 0a       	sbc	r7, r31
   6031e:	4c 14       	cp	r4, r12
   60320:	5d 04       	cpc	r5, r13
   60322:	6e 04       	cpc	r6, r14
   60324:	7f 04       	cpc	r7, r15
   60326:	79 f7       	brne	.-34     	; 0x60306 <BlockLoad+0x82>
	 nvm_eeprom_write_byte(address,value);
	 
	 (address)++; // Select next EEPROM byte
      }
      
      return '\r'; // Report programming OK
   60328:	8d e0       	ldi	r24, 0x0D	; 13
   6032a:	32 c0       	rjmp	.+100    	; 0x60390 <BlockLoad+0x10c>
   } 
   
   // Flash memory type
   else if(mem=='F')
   6032c:	66 34       	cpi	r22, 0x46	; 70
   6032e:	69 f5       	brne	.+90     	; 0x6038a <BlockLoad+0x106>
   { // NOTE: For flash programming, 'address' is given in words.
      address <<= 1; // Convert address to bytes temporarily.
   60330:	29 01       	movw	r4, r18
   60332:	3a 01       	movw	r6, r20
   60334:	44 0c       	add	r4, r4
   60336:	55 1c       	adc	r5, r5
   60338:	66 1c       	adc	r6, r6
   6033a:	77 1c       	adc	r7, r7
      EraseFlashBuffer(); //Erase the flash buffer to avoid data corruption
   6033c:	98 df       	rcall	.-208    	; 0x6026e <EraseFlashBuffer>
      for (int i = 0; i < size; i +=2) {
   6033e:	c1 14       	cp	r12, r1
   60340:	d1 04       	cpc	r13, r1
   60342:	d1 f0       	breq	.+52     	; 0x60378 <BlockLoad+0xf4>
   60344:	e1 2c       	mov	r14, r1
   60346:	f1 2c       	mov	r15, r1
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   60348:	00 ec       	ldi	r16, 0xC0	; 192
   6034a:	11 e0       	ldi	r17, 0x01	; 1
	 data = recchar();
   6034c:	58 d2       	rcall	.+1200   	; 0x607fe <recchar>
   6034e:	a8 2e       	mov	r10, r24
   60350:	b1 2c       	mov	r11, r1
	 data |= (uint16_t)recchar() << 8;
   60352:	55 d2       	rcall	.+1194   	; 0x607fe <recchar>
   60354:	a5 01       	movw	r20, r10
   60356:	58 2b       	or	r21, r24
   60358:	f8 01       	movw	r30, r16
   6035a:	87 85       	ldd	r24, Z+15	; 0x0f
   6035c:	88 23       	and	r24, r24
   6035e:	e4 f3       	brlt	.-8      	; 0x60358 <BlockLoad+0xd4>
	 
	 nvm_wait_until_ready();
#ifdef __ICCAVR__
#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
#endif
	 LoadFlashWord(i, data);
   60360:	b7 01       	movw	r22, r14
   60362:	88 27       	eor	r24, r24
   60364:	77 fd       	sbrc	r23, 7
   60366:	80 95       	com	r24
   60368:	98 2f       	mov	r25, r24
   /*Set the correct settings and store critical registers before NVM-workaround*/
#ifdef WORKAROUND
   Prepare_to_Sleep();
#endif
   /*Assembly "function" to load word into flash buffer*/
  nvm_flash_load_word_to_buffer(address, word);
   6036a:	62 d2       	rcall	.+1220   	; 0x60830 <nvm_flash_load_word_to_buffer>
   // Flash memory type
   else if(mem=='F')
   { // NOTE: For flash programming, 'address' is given in words.
      address <<= 1; // Convert address to bytes temporarily.
      EraseFlashBuffer(); //Erase the flash buffer to avoid data corruption
      for (int i = 0; i < size; i +=2) {
   6036c:	f2 e0       	ldi	r31, 0x02	; 2
   6036e:	ef 0e       	add	r14, r31
   60370:	f1 1c       	adc	r15, r1
   60372:	ec 14       	cp	r14, r12
   60374:	fd 04       	cpc	r15, r13
   60376:	50 f3       	brcs	.-44     	; 0x6034c <BlockLoad+0xc8>
      }
      
#ifdef __ICCAVR__
#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
#endif
      EraseWriteApplicationPage(address);
   60378:	c3 01       	movw	r24, r6
   6037a:	b2 01       	movw	r22, r4
   6037c:	70 df       	rcall	.-288    	; 0x6025e <EraseWriteApplicationPage>
   6037e:	e0 ec       	ldi	r30, 0xC0	; 192
   60380:	f1 e0       	ldi	r31, 0x01	; 1
   60382:	87 85       	ldd	r24, Z+15	; 0x0f
   60384:	88 23       	and	r24, r24
   60386:	ec f3       	brlt	.-6      	; 0x60382 <BlockLoad+0xfe>
   60388:	02 c0       	rjmp	.+4      	; 0x6038e <BlockLoad+0x10a>
   }
   
   // Invalid memory type?
   else
   {
      return '?';
   6038a:	8f e3       	ldi	r24, 0x3F	; 63
   6038c:	01 c0       	rjmp	.+2      	; 0x60390 <BlockLoad+0x10c>
#ifdef __ICCAVR__
#pragma diag_default=Pe1053 // Back to default.
#endif        
      nvm_wait_until_ready();
      
      return '\r'; // Report programming OK
   6038e:	8d e0       	ldi	r24, 0x0D	; 13
   // Invalid memory type?
   else
   {
      return '?';
   }
}
   60390:	de 5f       	subi	r29, 0xFE	; 254
   60392:	cd bf       	out	0x3d, r28	; 61
   60394:	de bf       	out	0x3e, r29	; 62
   60396:	df 91       	pop	r29
   60398:	cf 91       	pop	r28
   6039a:	1f 91       	pop	r17
   6039c:	0f 91       	pop	r16
   6039e:	ff 90       	pop	r15
   603a0:	ef 90       	pop	r14
   603a2:	df 90       	pop	r13
   603a4:	cf 90       	pop	r12
   603a6:	bf 90       	pop	r11
   603a8:	af 90       	pop	r10
   603aa:	9f 90       	pop	r9
   603ac:	8f 90       	pop	r8
   603ae:	7f 90       	pop	r7
   603b0:	6f 90       	pop	r6
   603b2:	5f 90       	pop	r5
   603b4:	4f 90       	pop	r4
   603b6:	08 95       	ret

000603b8 <BlockRead>:


void BlockRead(unsigned int size, unsigned char mem, ADDR_T address)
{
   603b8:	cf 92       	push	r12
   603ba:	df 92       	push	r13
   603bc:	ef 92       	push	r14
   603be:	ff 92       	push	r15
   603c0:	cf 93       	push	r28
   603c2:	df 93       	push	r29
   603c4:	ec 01       	movw	r28, r24
   603c6:	69 01       	movw	r12, r18
   603c8:	7a 01       	movw	r14, r20
   // EEPROM memory type.
   
   if (mem=='E') // Read EEPROM
   603ca:	65 34       	cpi	r22, 0x45	; 69
   603cc:	91 f4       	brne	.+36     	; 0x603f2 <BlockRead+0x3a>
 *  IO mapped access is now enabled.
 */
static inline void eeprom_disable_mapping(void)
{
#if !XMEGA_E
	NVM_CTRLB = NVM_CTRLB & ~NVM_EEMAPEN_bm;
   603ce:	ec ec       	ldi	r30, 0xCC	; 204
   603d0:	f1 e0       	ldi	r31, 0x01	; 1
   603d2:	80 81       	ld	r24, Z
   603d4:	87 7f       	andi	r24, 0xF7	; 247
   603d6:	80 83       	st	Z, r24
   {
      eeprom_disable_mapping();
      
	  nvm_eeprom_flush_buffer();
   603d8:	83 d1       	rcall	.+774    	; 0x606e0 <nvm_eeprom_flush_buffer>
      
      do
      {
	 sendchar(nvm_eeprom_read_byte(address));
   603da:	c6 01       	movw	r24, r12
   603dc:	70 d1       	rcall	.+736    	; 0x606be <nvm_eeprom_read_byte>
   603de:	02 d2       	rcall	.+1028   	; 0x607e4 <sendchar>
	 // Select next EEPROM byte
	 (address)++;            
   603e0:	8f ef       	ldi	r24, 0xFF	; 255
   603e2:	c8 1a       	sub	r12, r24
   603e4:	d8 0a       	sbc	r13, r24
   603e6:	e8 0a       	sbc	r14, r24
   603e8:	f8 0a       	sbc	r15, r24
	 size--; // Decrease number of bytes to read
   603ea:	21 97       	sbiw	r28, 0x01	; 1
      } while (size); // Repeat until all block has been read
   603ec:	20 97       	sbiw	r28, 0x00	; 0
   603ee:	a9 f7       	brne	.-22     	; 0x603da <BlockRead+0x22>
   603f0:	1b c0       	rjmp	.+54     	; 0x60428 <BlockRead+0x70>
   }
   
   // Flash memory type.
   else if(mem=='F')
   603f2:	66 34       	cpi	r22, 0x46	; 70
   603f4:	c9 f4       	brne	.+50     	; 0x60428 <BlockRead+0x70>
   {
      (address) <<= 1; // Convert address to bytes temporarily.
   603f6:	cc 0c       	add	r12, r12
   603f8:	dd 1c       	adc	r13, r13
   603fa:	ee 1c       	adc	r14, r14
   603fc:	ff 1c       	adc	r15, r15
      do
      {
#ifdef __ICCAVR__
#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
#endif
	 sendchar( nvm_flash_read_byte( address) );
   603fe:	eb be       	out	0x3b, r14	; 59
   60400:	f6 01       	movw	r30, r12
   60402:	87 91       	elpm	r24, Z+
   60404:	ef d1       	rcall	.+990    	; 0x607e4 <sendchar>
	 sendchar( nvm_flash_read_byte( (address)+1) );
   60406:	d7 01       	movw	r26, r14
   60408:	c6 01       	movw	r24, r12
   6040a:	01 96       	adiw	r24, 0x01	; 1
   6040c:	a1 1d       	adc	r26, r1
   6040e:	b1 1d       	adc	r27, r1
   60410:	ab bf       	out	0x3b, r26	; 59
   60412:	fc 01       	movw	r30, r24
   60414:	87 91       	elpm	r24, Z+
   60416:	e6 d1       	rcall	.+972    	; 0x607e4 <sendchar>
#ifdef __ICCAVR__
#pragma diag_default=Pe1053     // Back to default.
#endif
	 (address) += 2;    // Select next word in memory.
   60418:	82 e0       	ldi	r24, 0x02	; 2
   6041a:	c8 0e       	add	r12, r24
   6041c:	d1 1c       	adc	r13, r1
   6041e:	e1 1c       	adc	r14, r1
   60420:	f1 1c       	adc	r15, r1
	 size -= 2;          // Subtract two bytes from number of bytes to read
   60422:	22 97       	sbiw	r28, 0x02	; 2
      } while (size);         // Repeat until all block has been read
   60424:	20 97       	sbiw	r28, 0x00	; 0
   60426:	59 f7       	brne	.-42     	; 0x603fe <BlockRead+0x46>
      
      (address) >>= 1;       // Convert address back to Flash words again.
   }
}
   60428:	df 91       	pop	r29
   6042a:	cf 91       	pop	r28
   6042c:	ff 90       	pop	r15
   6042e:	ef 90       	pop	r14
   60430:	df 90       	pop	r13
   60432:	cf 90       	pop	r12
   60434:	08 95       	ret

00060436 <main>:
   unsigned char val;
   
   /* Initialization */    
   void (*funcptr)( void ) = 0x0000; // Set up function pointer to RESET vector.
   
   PMIC_SetVectorLocationToBoot();
   60436:	fb de       	rcall	.-522    	; 0x6022e <PMIC_SetVectorLocationToBoot>
   60438:	ec ec       	ldi	r30, 0xCC	; 204
   6043a:	f1 e0       	ldi	r31, 0x01	; 1
   6043c:	80 81       	ld	r24, Z
   6043e:	87 7f       	andi	r24, 0xF7	; 247
   60440:	80 83       	st	Z, r24
   
   
   eeprom_disable_mapping();
   
   PROGPORT |= (1<<PROG_NO); // Enable pull-up on PROG_NO line on PROGPORT.
   60442:	e0 e6       	ldi	r30, 0x60	; 96
   60444:	f6 e0       	ldi	r31, 0x06	; 6
   60446:	84 81       	ldd	r24, Z+4	; 0x04
   60448:	80 61       	ori	r24, 0x10	; 16
   6044a:	84 83       	std	Z+4, r24	; 0x04
   
   /* Branch to bootloader or application code? */
   if( /*!(PROGPIN & (1<<PROG_NO))*/1 ) // If PROGPIN is pulled low, enter programmingmode.
   {
      initbootuart(); // Initialize UART.
   6044c:	bf d1       	rcall	.+894    	; 0x607cc <initbootuart>
}

int main(void)
{
   ADDR_T address = 0;
   unsigned int temp_int=0;
   6044e:	00 e0       	ldi	r16, 0x00	; 0
   60450:	10 e0       	ldi	r17, 0x00	; 0
    nvm_flash_flush_buffer();
}

int main(void)
{
   ADDR_T address = 0;
   60452:	c1 2c       	mov	r12, r1
   60454:	d1 2c       	mov	r13, r1
   60456:	76 01       	movw	r14, r12
 */
static inline void nvm_wait_until_ready( void )
{
	do {
		// Block execution while waiting for the NVM to be ready
	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
   60458:	c0 ec       	ldi	r28, 0xC0	; 192
   6045a:	d1 e0       	ldi	r29, 0x01	; 1

      /* Main loop */
      for(;;)
      {
	 
	 val = recchar(); // Wait for command character.
   6045c:	d0 d1       	rcall	.+928    	; 0x607fe <recchar>
	 
	 // Check autoincrement status.
	 if(val=='a')
   6045e:	81 36       	cpi	r24, 0x61	; 97
   60460:	19 f4       	brne	.+6      	; 0x60468 <main+0x32>
	 {
	    sendchar('Y'); // Yes, we do autoincrement.
   60462:	89 e5       	ldi	r24, 0x59	; 89
   60464:	bf d1       	rcall	.+894    	; 0x607e4 <sendchar>
   60466:	fa cf       	rjmp	.-12     	; 0x6045c <main+0x26>
	 }
	 
	 // Set address (2 bytes).
	 else if(val == 'A')
   60468:	81 34       	cpi	r24, 0x41	; 65
   6046a:	71 f4       	brne	.+28     	; 0x60488 <main+0x52>
	 { // NOTE: Flash addresses are given in words, not bytes.                                            
	    address = recchar();
   6046c:	c8 d1       	rcall	.+912    	; 0x607fe <recchar>
   6046e:	c8 2e       	mov	r12, r24
   60470:	d1 2c       	mov	r13, r1
   60472:	e1 2c       	mov	r14, r1
   60474:	f1 2c       	mov	r15, r1
	    address <<=  8;
   60476:	fe 2c       	mov	r15, r14
   60478:	ed 2c       	mov	r14, r13
   6047a:	dc 2c       	mov	r13, r12
   6047c:	cc 24       	eor	r12, r12
	    address |= recchar(); // Read address high and low byte.
   6047e:	bf d1       	rcall	.+894    	; 0x607fe <recchar>
   60480:	c8 2a       	or	r12, r24
	    sendchar('\r'); // Send OK back.
   60482:	8d e0       	ldi	r24, 0x0D	; 13
   60484:	af d1       	rcall	.+862    	; 0x607e4 <sendchar>
   60486:	ea cf       	rjmp	.-44     	; 0x6045c <main+0x26>
	 }

	 // Set extended address (3 bytes).
	 else if(val == 'H')
   60488:	88 34       	cpi	r24, 0x48	; 72
   6048a:	c9 f4       	brne	.+50     	; 0x604be <main+0x88>
	 { // NOTE: Flash addresses are given in words, not bytes.                                            
	    address = (uint32_t)recchar() << 16;
   6048c:	b8 d1       	rcall	.+880    	; 0x607fe <recchar>
   6048e:	c8 2e       	mov	r12, r24
   60490:	d1 2c       	mov	r13, r1
   60492:	e1 2c       	mov	r14, r1
   60494:	f1 2c       	mov	r15, r1
   60496:	76 01       	movw	r14, r12
   60498:	dd 24       	eor	r13, r13
   6049a:	cc 24       	eor	r12, r12
	    address |= (uint16_t)recchar() << 8;
   6049c:	b0 d1       	rcall	.+864    	; 0x607fe <recchar>
   6049e:	b8 2e       	mov	r11, r24
	    address |= recchar();
   604a0:	ae d1       	rcall	.+860    	; 0x607fe <recchar>

	 // Set extended address (3 bytes).
	 else if(val == 'H')
	 { // NOTE: Flash addresses are given in words, not bytes.                                            
	    address = (uint32_t)recchar() << 16;
	    address |= (uint16_t)recchar() << 8;
   604a2:	c8 2a       	or	r12, r24
   604a4:	8b 2d       	mov	r24, r11
   604a6:	90 e0       	ldi	r25, 0x00	; 0
   604a8:	98 2f       	mov	r25, r24
   604aa:	88 27       	eor	r24, r24
   604ac:	a0 e0       	ldi	r26, 0x00	; 0
   604ae:	b0 e0       	ldi	r27, 0x00	; 0
	    address |= recchar();
   604b0:	c8 2a       	or	r12, r24
   604b2:	d9 2a       	or	r13, r25
   604b4:	ea 2a       	or	r14, r26
   604b6:	fb 2a       	or	r15, r27
	    sendchar('\r'); // Send OK back.
   604b8:	8d e0       	ldi	r24, 0x0D	; 13
   604ba:	94 d1       	rcall	.+808    	; 0x607e4 <sendchar>
   604bc:	cf cf       	rjmp	.-98     	; 0x6045c <main+0x26>
	 }

	 // Chip erase.
	 else if(val=='e')
   604be:	85 36       	cpi	r24, 0x65	; 101
   604c0:	b9 f4       	brne	.+46     	; 0x604f0 <main+0xba>
   604c2:	c1 2c       	mov	r12, r1
   604c4:	d1 2c       	mov	r13, r1
   604c6:	76 01       	movw	r14, r12
   604c8:	8f 85       	ldd	r24, Y+15	; 0x0f
   604ca:	88 23       	and	r24, r24
   604cc:	ec f3       	brlt	.-6      	; 0x604c8 <main+0x92>
	    { // NOTE: Here we use address as a byte-address, not word-address, for convenience.
	       nvm_wait_until_ready();
#ifdef __ICCAVR__
#pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
#endif
	       EraseApplicationPage( address );
   604ce:	c7 01       	movw	r24, r14
   604d0:	b6 01       	movw	r22, r12
   604d2:	bd de       	rcall	.-646    	; 0x6024e <EraseApplicationPage>
	 }

	 // Chip erase.
	 else if(val=='e')
	 {
	    for(address = 0; address < APP_END; address += PAGESIZE)
   604d4:	82 e0       	ldi	r24, 0x02	; 2
   604d6:	d8 0e       	add	r13, r24
   604d8:	e1 1c       	adc	r14, r1
   604da:	f1 1c       	adc	r15, r1
   604dc:	c1 14       	cp	r12, r1
   604de:	d1 04       	cpc	r13, r1
   604e0:	e6 e0       	ldi	r30, 0x06	; 6
   604e2:	ee 06       	cpc	r14, r30
   604e4:	f1 04       	cpc	r15, r1
   604e6:	81 f7       	brne	.-32     	; 0x604c8 <main+0x92>
	       EraseApplicationPage( address );
#ifdef __ICCAVR__
#pragma diag_default=Pe1053 // Back to default.
#endif
	    }
	    nvm_eeprom_erase_all();
   604e8:	6d d1       	rcall	.+730    	; 0x607c4 <nvm_eeprom_erase_all>
	    sendchar('\r'); // Send OK back.
   604ea:	8d e0       	ldi	r24, 0x0D	; 13
   604ec:	7b d1       	rcall	.+758    	; 0x607e4 <sendchar>
   604ee:	b6 cf       	rjmp	.-148    	; 0x6045c <main+0x26>
	 }
	 
#ifndef REMOVE_BLOCK_SUPPORT

	 // Check block load support.
	 else if(val=='b')
   604f0:	82 36       	cpi	r24, 0x62	; 98
   604f2:	39 f4       	brne	.+14     	; 0x60502 <main+0xcc>
	 {
	    sendchar('Y'); // Report block load supported.
   604f4:	89 e5       	ldi	r24, 0x59	; 89
   604f6:	76 d1       	rcall	.+748    	; 0x607e4 <sendchar>
	    sendchar((BLOCKSIZE>>8) & 0xFF); // MSB first.
   604f8:	82 e0       	ldi	r24, 0x02	; 2
   604fa:	74 d1       	rcall	.+744    	; 0x607e4 <sendchar>
	    sendchar(BLOCKSIZE&0xFF); // Report BLOCKSIZE (bytes).
   604fc:	80 e0       	ldi	r24, 0x00	; 0
   604fe:	72 d1       	rcall	.+740    	; 0x607e4 <sendchar>
   60500:	ad cf       	rjmp	.-166    	; 0x6045c <main+0x26>
	 }
	 
	 // Start block load.
	 else if(val=='B')
   60502:	82 34       	cpi	r24, 0x42	; 66
   60504:	79 f4       	brne	.+30     	; 0x60524 <main+0xee>
	 {
	    temp_int = ((uint16_t)recchar()<<8) | recchar(); // Get block size.
   60506:	7b d1       	rcall	.+758    	; 0x607fe <recchar>
   60508:	08 2f       	mov	r16, r24
   6050a:	79 d1       	rcall	.+754    	; 0x607fe <recchar>
   6050c:	10 e0       	ldi	r17, 0x00	; 0
   6050e:	10 2f       	mov	r17, r16
   60510:	00 27       	eor	r16, r16
   60512:	08 2b       	or	r16, r24
	    val = recchar(); // Get memtype.
   60514:	74 d1       	rcall	.+744    	; 0x607fe <recchar>
	    sendchar( BlockLoad(temp_int, val, address) ); // Block load.				
   60516:	a7 01       	movw	r20, r14
   60518:	96 01       	movw	r18, r12
   6051a:	68 2f       	mov	r22, r24
   6051c:	c8 01       	movw	r24, r16
   6051e:	b2 de       	rcall	.-668    	; 0x60284 <BlockLoad>
   60520:	61 d1       	rcall	.+706    	; 0x607e4 <sendchar>
   60522:	9c cf       	rjmp	.-200    	; 0x6045c <main+0x26>
	 }	    
	 // Start block read.
	 else if(val=='g')
   60524:	87 36       	cpi	r24, 0x67	; 103
   60526:	71 f4       	brne	.+28     	; 0x60544 <main+0x10e>
	 {
	    temp_int = ((uint16_t)recchar()<<8) | recchar(); // Get block size.
   60528:	6a d1       	rcall	.+724    	; 0x607fe <recchar>
   6052a:	08 2f       	mov	r16, r24
   6052c:	68 d1       	rcall	.+720    	; 0x607fe <recchar>
   6052e:	10 e0       	ldi	r17, 0x00	; 0
   60530:	10 2f       	mov	r17, r16
   60532:	00 27       	eor	r16, r16
   60534:	08 2b       	or	r16, r24
	    val = recchar(); // Get memtype
   60536:	63 d1       	rcall	.+710    	; 0x607fe <recchar>
	    BlockRead(temp_int, val, address); // Block read
   60538:	a7 01       	movw	r20, r14
   6053a:	96 01       	movw	r18, r12
   6053c:	68 2f       	mov	r22, r24
   6053e:	c8 01       	movw	r24, r16
   60540:	3b df       	rcall	.-394    	; 0x603b8 <BlockRead>
   60542:	8c cf       	rjmp	.-232    	; 0x6045c <main+0x26>
	 }		
#endif /* REMOVE_BLOCK_SUPPORT */
	 
#ifndef REMOVE_FLASH_BYTE_SUPPORT            
	 // Read program memory.
	 else if(val=='R')
   60544:	82 35       	cpi	r24, 0x52	; 82
   60546:	e1 f4       	brne	.+56     	; 0x60580 <main+0x14a>
   60548:	8f 85       	ldd	r24, Y+15	; 0x0f
   6054a:	88 23       	and	r24, r24
   6054c:	ec f3       	brlt	.-6      	; 0x60548 <main+0x112>
	 {        
	    // Send high byte, then low byte of flash word.
	    nvm_wait_until_ready();
	    sendchar(nvm_flash_read_byte( (address << 1)+1) );
   6054e:	46 01       	movw	r8, r12
   60550:	57 01       	movw	r10, r14
   60552:	88 0c       	add	r8, r8
   60554:	99 1c       	adc	r9, r9
   60556:	aa 1c       	adc	r10, r10
   60558:	bb 1c       	adc	r11, r11
   6055a:	d5 01       	movw	r26, r10
   6055c:	c4 01       	movw	r24, r8
   6055e:	01 96       	adiw	r24, 0x01	; 1
   60560:	a1 1d       	adc	r26, r1
   60562:	b1 1d       	adc	r27, r1
   60564:	ab bf       	out	0x3b, r26	; 59
   60566:	fc 01       	movw	r30, r24
   60568:	87 91       	elpm	r24, Z+
   6056a:	3c d1       	rcall	.+632    	; 0x607e4 <sendchar>
	    sendchar( nvm_flash_read_byte( (address << 1)+0) );
   6056c:	ab be       	out	0x3b, r10	; 59
   6056e:	f4 01       	movw	r30, r8
   60570:	87 91       	elpm	r24, Z+
   60572:	38 d1       	rcall	.+624    	; 0x607e4 <sendchar>
	    address++; // Auto-advance to next Flash word.
   60574:	ff ef       	ldi	r31, 0xFF	; 255
   60576:	cf 1a       	sub	r12, r31
   60578:	df 0a       	sbc	r13, r31
   6057a:	ef 0a       	sbc	r14, r31
   6057c:	ff 0a       	sbc	r15, r31
   6057e:	6e cf       	rjmp	.-292    	; 0x6045c <main+0x26>
	 }
	 
	 // Write program memory, low byte.        
	 else if(val=='c')
   60580:	83 36       	cpi	r24, 0x63	; 99
   60582:	31 f4       	brne	.+12     	; 0x60590 <main+0x15a>
	 { // NOTE: Always use this command before sending high byte.
	    temp_int=recchar(); // Get low byte for later LoadFlashWord
   60584:	3c d1       	rcall	.+632    	; 0x607fe <recchar>
   60586:	08 2f       	mov	r16, r24
   60588:	10 e0       	ldi	r17, 0x00	; 0
	    sendchar('\r'); // Send OK back.
   6058a:	8d e0       	ldi	r24, 0x0D	; 13
   6058c:	2b d1       	rcall	.+598    	; 0x607e4 <sendchar>
   6058e:	66 cf       	rjmp	.-308    	; 0x6045c <main+0x26>
	 }
	 
	 // Write program memory, high byte.
	 else if(val=='C')
   60590:	83 34       	cpi	r24, 0x43	; 67
   60592:	a9 f4       	brne	.+42     	; 0x605be <main+0x188>
	 {
	    temp_int |= (uint16_t)recchar()<<8; // Get and insert high byte.
   60594:	34 d1       	rcall	.+616    	; 0x607fe <recchar>
   60596:	18 2b       	or	r17, r24
   60598:	8f 85       	ldd	r24, Y+15	; 0x0f
   6059a:	88 23       	and	r24, r24
   6059c:	ec f3       	brlt	.-6      	; 0x60598 <main+0x162>
	    nvm_wait_until_ready();
	    LoadFlashWord( (address << 1), temp_int );
   6059e:	c7 01       	movw	r24, r14
   605a0:	b6 01       	movw	r22, r12
   605a2:	66 0f       	add	r22, r22
   605a4:	77 1f       	adc	r23, r23
   605a6:	88 1f       	adc	r24, r24
   605a8:	99 1f       	adc	r25, r25
   /*Set the correct settings and store critical registers before NVM-workaround*/
#ifdef WORKAROUND
   Prepare_to_Sleep();
#endif
   /*Assembly "function" to load word into flash buffer*/
  nvm_flash_load_word_to_buffer(address, word);
   605aa:	a8 01       	movw	r20, r16
   605ac:	41 d1       	rcall	.+642    	; 0x60830 <nvm_flash_load_word_to_buffer>
	 else if(val=='C')
	 {
	    temp_int |= (uint16_t)recchar()<<8; // Get and insert high byte.
	    nvm_wait_until_ready();
	    LoadFlashWord( (address << 1), temp_int );
	    address++; // Auto-advance to next Flash word.
   605ae:	8f ef       	ldi	r24, 0xFF	; 255
   605b0:	c8 1a       	sub	r12, r24
   605b2:	d8 0a       	sbc	r13, r24
   605b4:	e8 0a       	sbc	r14, r24
   605b6:	f8 0a       	sbc	r15, r24
	    sendchar('\r'); // Send OK back.
   605b8:	8d e0       	ldi	r24, 0x0D	; 13
   605ba:	14 d1       	rcall	.+552    	; 0x607e4 <sendchar>
   605bc:	4f cf       	rjmp	.-354    	; 0x6045c <main+0x26>
	 }
	 
	 // Write page.       
	 else if(val== 'm')
   605be:	8d 36       	cpi	r24, 0x6D	; 109
   605c0:	b1 f4       	brne	.+44     	; 0x605ee <main+0x1b8>
	 {
	    if( address >= (APP_END>>1) ) // Protect bootloader area.		    
   605c2:	c1 14       	cp	r12, r1
   605c4:	d1 04       	cpc	r13, r1
   605c6:	e3 e0       	ldi	r30, 0x03	; 3
   605c8:	ee 06       	cpc	r14, r30
   605ca:	f1 04       	cpc	r15, r1
   605cc:	18 f0       	brcs	.+6      	; 0x605d4 <main+0x19e>
	    {
	       sendchar('?');
   605ce:	8f e3       	ldi	r24, 0x3F	; 63
   605d0:	09 d1       	rcall	.+530    	; 0x607e4 <sendchar>
   605d2:	44 cf       	rjmp	.-376    	; 0x6045c <main+0x26>
   605d4:	8f 85       	ldd	r24, Y+15	; 0x0f
   605d6:	88 23       	and	r24, r24
   605d8:	ec f3       	brlt	.-6      	; 0x605d4 <main+0x19e>
	    } 
	    else
	    {
	       nvm_wait_until_ready();
	       // Convert word-address to byte-address and write.
	       EraseWriteApplicationPage( address << 1);
   605da:	c7 01       	movw	r24, r14
   605dc:	b6 01       	movw	r22, r12
   605de:	66 0f       	add	r22, r22
   605e0:	77 1f       	adc	r23, r23
   605e2:	88 1f       	adc	r24, r24
   605e4:	99 1f       	adc	r25, r25
   605e6:	3b de       	rcall	.-906    	; 0x6025e <EraseWriteApplicationPage>
	       sendchar('\r'); // Send OK back.
   605e8:	8d e0       	ldi	r24, 0x0D	; 13
   605ea:	fc d0       	rcall	.+504    	; 0x607e4 <sendchar>
   605ec:	37 cf       	rjmp	.-402    	; 0x6045c <main+0x26>
#endif // REMOVE_FLASH_BYTE_SUPPORT
	    
#ifndef REMOVE_EEPROM_BYTE_SUPPORT
	 }
	 // Write EEPROM memory.
	 else if (val == 'D')
   605ee:	84 34       	cpi	r24, 0x44	; 68
   605f0:	51 f4       	brne	.+20     	; 0x60606 <main+0x1d0>
	 {
	    nvm_eeprom_write_byte(address,recchar());
   605f2:	05 d1       	rcall	.+522    	; 0x607fe <recchar>
   605f4:	68 2f       	mov	r22, r24
   605f6:	c6 01       	movw	r24, r12
   605f8:	96 d0       	rcall	.+300    	; 0x60726 <nvm_eeprom_write_byte>
	    // Select next EEPROM byte
	    address++;
   605fa:	ff ef       	ldi	r31, 0xFF	; 255
   605fc:	cf 1a       	sub	r12, r31
   605fe:	df 0a       	sbc	r13, r31
   60600:	ef 0a       	sbc	r14, r31
   60602:	ff 0a       	sbc	r15, r31
   60604:	2b cf       	rjmp	.-426    	; 0x6045c <main+0x26>
	 }
	 
	 // Read EEPROM memory.
	 else if (val == 'd')
   60606:	84 36       	cpi	r24, 0x64	; 100
   60608:	49 f4       	brne	.+18     	; 0x6061c <main+0x1e6>
	 {
	    sendchar(nvm_eeprom_read_byte(address));
   6060a:	c6 01       	movw	r24, r12
   6060c:	58 d0       	rcall	.+176    	; 0x606be <nvm_eeprom_read_byte>
   6060e:	ea d0       	rcall	.+468    	; 0x607e4 <sendchar>
	    // Select next EEPROM byte
	    address++;
   60610:	8f ef       	ldi	r24, 0xFF	; 255
   60612:	c8 1a       	sub	r12, r24
   60614:	d8 0a       	sbc	r13, r24
   60616:	e8 0a       	sbc	r14, r24
   60618:	f8 0a       	sbc	r15, r24
   6061a:	20 cf       	rjmp	.-448    	; 0x6045c <main+0x26>
#endif 

	 
#ifndef REMOVE_AVRPROG_SUPPORT        
	 // Enter and leave programming mode.
	 else if((val=='P')||(val=='L'))
   6061c:	80 35       	cpi	r24, 0x50	; 80
   6061e:	11 f0       	breq	.+4      	; 0x60624 <main+0x1ee>
   60620:	8c 34       	cpi	r24, 0x4C	; 76
   60622:	19 f4       	brne	.+6      	; 0x6062a <main+0x1f4>
	 {
	    sendchar('\r'); // Nothing special to do, just answer OK.
   60624:	8d e0       	ldi	r24, 0x0D	; 13
   60626:	de d0       	rcall	.+444    	; 0x607e4 <sendchar>
   60628:	19 cf       	rjmp	.-462    	; 0x6045c <main+0x26>
	 }
	 // Exit bootloader.
	 else if(val=='E')
   6062a:	85 34       	cpi	r24, 0x45	; 69
   6062c:	59 f4       	brne	.+22     	; 0x60644 <main+0x20e>
   6062e:	8f 85       	ldd	r24, Y+15	; 0x0f
   60630:	88 23       	and	r24, r24
   60632:	ec f3       	brlt	.-6      	; 0x6062e <main+0x1f8>
	 {
	    nvm_wait_until_ready();
	    sendchar('\r');
   60634:	8d e0       	ldi	r24, 0x0D	; 13
   60636:	d6 d0       	rcall	.+428    	; 0x607e4 <sendchar>
	    PMIC_SetVectorLocationToApplication();
   60638:	02 de       	rcall	.-1020   	; 0x6023e <PMIC_SetVectorLocationToApplication>
	    EIND = 0x00;
   6063a:	1c be       	out	0x3c, r1	; 60
	    funcptr(); // Jump to Reset vector 0x0000 in Application Section.
   6063c:	e0 e0       	ldi	r30, 0x00	; 0
   6063e:	f0 e0       	ldi	r31, 0x00	; 0
   60640:	19 95       	eicall
   60642:	0c cf       	rjmp	.-488    	; 0x6045c <main+0x26>
	 }
	 // Get programmer type.        
	 else if (val=='p')
   60644:	80 37       	cpi	r24, 0x70	; 112
   60646:	19 f4       	brne	.+6      	; 0x6064e <main+0x218>
	 {
	    sendchar('S'); // Answer 'SERIAL'.
   60648:	83 e5       	ldi	r24, 0x53	; 83
   6064a:	cc d0       	rcall	.+408    	; 0x607e4 <sendchar>
   6064c:	07 cf       	rjmp	.-498    	; 0x6045c <main+0x26>
	 }
	 // Return supported device codes.
	 else if(val=='t')
   6064e:	84 37       	cpi	r24, 0x74	; 116
   60650:	29 f4       	brne	.+10     	; 0x6065c <main+0x226>
	 {
#if PARTCODE+0 > 0
	    sendchar( PARTCODE ); // Supports only this device, of course.
   60652:	8a ef       	ldi	r24, 0xFA	; 250
   60654:	c7 d0       	rcall	.+398    	; 0x607e4 <sendchar>
#endif /* PARTCODE */
	    sendchar( 0 ); // Send list terminator.
   60656:	80 e0       	ldi	r24, 0x00	; 0
   60658:	c5 d0       	rcall	.+394    	; 0x607e4 <sendchar>
   6065a:	00 cf       	rjmp	.-512    	; 0x6045c <main+0x26>
	 }
	 // Set LED, clear LED and set device type.
	 else if((val=='x')||(val=='y')||(val=='T'))
   6065c:	98 e8       	ldi	r25, 0x88	; 136
   6065e:	98 0f       	add	r25, r24
   60660:	92 30       	cpi	r25, 0x02	; 2
   60662:	10 f0       	brcs	.+4      	; 0x60668 <main+0x232>
   60664:	84 35       	cpi	r24, 0x54	; 84
   60666:	21 f4       	brne	.+8      	; 0x60670 <main+0x23a>
	 {
	    recchar(); // Ignore the command and it's parameter.
   60668:	ca d0       	rcall	.+404    	; 0x607fe <recchar>
	    sendchar('\r'); // Send OK back.
   6066a:	8d e0       	ldi	r24, 0x0D	; 13
   6066c:	bb d0       	rcall	.+374    	; 0x607e4 <sendchar>
   6066e:	f6 ce       	rjmp	.-532    	; 0x6045c <main+0x26>
	 }
#endif /* REMOVE_AVRPROG_SUPPORT */
	 // Return programmer identifier.
	 else if(val=='S')
   60670:	83 35       	cpi	r24, 0x53	; 83
   60672:	79 f4       	brne	.+30     	; 0x60692 <main+0x25c>
	 {
	    sendchar('A'); // Return 'AVRBOOT'.
   60674:	81 e4       	ldi	r24, 0x41	; 65
   60676:	b6 d0       	rcall	.+364    	; 0x607e4 <sendchar>
	    sendchar('V'); // Software identifier (aka programmer signature) is always 7 characters.
   60678:	86 e5       	ldi	r24, 0x56	; 86
   6067a:	b4 d0       	rcall	.+360    	; 0x607e4 <sendchar>
	    sendchar('R');
   6067c:	82 e5       	ldi	r24, 0x52	; 82
   6067e:	b2 d0       	rcall	.+356    	; 0x607e4 <sendchar>
	    sendchar('B');
   60680:	82 e4       	ldi	r24, 0x42	; 66
   60682:	b0 d0       	rcall	.+352    	; 0x607e4 <sendchar>
	    sendchar('O');
   60684:	8f e4       	ldi	r24, 0x4F	; 79
   60686:	ae d0       	rcall	.+348    	; 0x607e4 <sendchar>
	    sendchar('O');
   60688:	8f e4       	ldi	r24, 0x4F	; 79
   6068a:	ac d0       	rcall	.+344    	; 0x607e4 <sendchar>
	    sendchar('T');
   6068c:	84 e5       	ldi	r24, 0x54	; 84
   6068e:	aa d0       	rcall	.+340    	; 0x607e4 <sendchar>
   60690:	e5 ce       	rjmp	.-566    	; 0x6045c <main+0x26>
	 }
	 // Return software version.
	 else if(val=='V')
   60692:	86 35       	cpi	r24, 0x56	; 86
   60694:	29 f4       	brne	.+10     	; 0x606a0 <main+0x26a>
	 {
	    sendchar('1');
   60696:	81 e3       	ldi	r24, 0x31	; 49
   60698:	a5 d0       	rcall	.+330    	; 0x607e4 <sendchar>
	    sendchar('7');
   6069a:	87 e3       	ldi	r24, 0x37	; 55
   6069c:	a3 d0       	rcall	.+326    	; 0x607e4 <sendchar>
   6069e:	de ce       	rjmp	.-580    	; 0x6045c <main+0x26>
	 }        
	 // Return signature bytes.
	 else if(val=='s')
   606a0:	83 37       	cpi	r24, 0x73	; 115
   606a2:	39 f4       	brne	.+14     	; 0x606b2 <main+0x27c>
	 {							
	    sendchar( SIGNATURE_BYTE_3 );
   606a4:	85 e4       	ldi	r24, 0x45	; 69
   606a6:	9e d0       	rcall	.+316    	; 0x607e4 <sendchar>
	    sendchar( SIGNATURE_BYTE_2 );
   606a8:	88 e9       	ldi	r24, 0x98	; 152
   606aa:	9c d0       	rcall	.+312    	; 0x607e4 <sendchar>
	    sendchar( SIGNATURE_BYTE_1 );
   606ac:	8e e1       	ldi	r24, 0x1E	; 30
   606ae:	9a d0       	rcall	.+308    	; 0x607e4 <sendchar>
   606b0:	d5 ce       	rjmp	.-598    	; 0x6045c <main+0x26>
	 }       
	 // The last command to accept is ESC (synchronization).
	 else if(val!=0x1b) // If not ESC, then it is unrecognized...
   606b2:	8b 31       	cpi	r24, 0x1B	; 27
   606b4:	09 f4       	brne	.+2      	; 0x606b8 <main+0x282>
   606b6:	d2 ce       	rjmp	.-604    	; 0x6045c <main+0x26>
	 {
	    sendchar('?');
   606b8:	8f e3       	ldi	r24, 0x3F	; 63
   606ba:	94 d0       	rcall	.+296    	; 0x607e4 <sendchar>
   606bc:	cf ce       	rjmp	.-610    	; 0x6045c <main+0x26>

000606be <nvm_eeprom_read_byte>:
{
	// Mark all addresses to be deleted
	nvm_eeprom_fill_buffer_with_value(0xff);
	// Erase bytes
	nvm_eeprom_erase_bytes_in_page(page_addr);
}
   606be:	e0 ec       	ldi	r30, 0xC0	; 192
   606c0:	f1 e0       	ldi	r31, 0x01	; 1
   606c2:	27 85       	ldd	r18, Z+15	; 0x0f
   606c4:	22 23       	and	r18, r18
   606c6:	ec f3       	brlt	.-6      	; 0x606c2 <nvm_eeprom_read_byte+0x4>
   606c8:	ec ec       	ldi	r30, 0xCC	; 204
   606ca:	f1 e0       	ldi	r31, 0x01	; 1
   606cc:	20 81       	ld	r18, Z
   606ce:	28 60       	ori	r18, 0x08	; 8
   606d0:	20 83       	st	Z, r18
   606d2:	dc 01       	movw	r26, r24
   606d4:	b0 5f       	subi	r27, 0xF0	; 240
   606d6:	8c 91       	ld	r24, X
   606d8:	90 81       	ld	r25, Z
   606da:	97 7f       	andi	r25, 0xF7	; 247
   606dc:	90 83       	st	Z, r25
   606de:	08 95       	ret

000606e0 <nvm_eeprom_flush_buffer>:
   606e0:	e0 ec       	ldi	r30, 0xC0	; 192
   606e2:	f1 e0       	ldi	r31, 0x01	; 1
   606e4:	87 85       	ldd	r24, Z+15	; 0x0f
   606e6:	88 23       	and	r24, r24
   606e8:	ec f3       	brlt	.-6      	; 0x606e4 <nvm_eeprom_flush_buffer+0x4>
   606ea:	e0 ec       	ldi	r30, 0xC0	; 192
   606ec:	f1 e0       	ldi	r31, 0x01	; 1
   606ee:	87 85       	ldd	r24, Z+15	; 0x0f
   606f0:	81 ff       	sbrs	r24, 1
   606f2:	06 c0       	rjmp	.+12     	; 0x60700 <nvm_eeprom_flush_buffer+0x20>
   606f4:	86 e3       	ldi	r24, 0x36	; 54
   606f6:	82 87       	std	Z+10, r24	; 0x0a
   606f8:	61 e0       	ldi	r22, 0x01	; 1
   606fa:	8b ec       	ldi	r24, 0xCB	; 203
   606fc:	91 e0       	ldi	r25, 0x01	; 1
   606fe:	91 cd       	rjmp	.-1246   	; 0x60222 <ccp_write_io>
   60700:	08 95       	ret

00060702 <nvm_eeprom_load_byte_to_buffer>:
   60702:	e0 ec       	ldi	r30, 0xC0	; 192
   60704:	f1 e0       	ldi	r31, 0x01	; 1
   60706:	97 85       	ldd	r25, Z+15	; 0x0f
   60708:	99 23       	and	r25, r25
   6070a:	ec f3       	brlt	.-6      	; 0x60706 <nvm_eeprom_load_byte_to_buffer+0x4>
   6070c:	ec ec       	ldi	r30, 0xCC	; 204
   6070e:	f1 e0       	ldi	r31, 0x01	; 1
   60710:	90 81       	ld	r25, Z
   60712:	98 60       	ori	r25, 0x08	; 8
   60714:	90 83       	st	Z, r25
   60716:	a8 2f       	mov	r26, r24
   60718:	b0 e0       	ldi	r27, 0x00	; 0
   6071a:	b0 5f       	subi	r27, 0xF0	; 240
   6071c:	6c 93       	st	X, r22
   6071e:	80 81       	ld	r24, Z
   60720:	87 7f       	andi	r24, 0xF7	; 247
   60722:	80 83       	st	Z, r24
   60724:	08 95       	ret

00060726 <nvm_eeprom_write_byte>:
   60726:	ff 92       	push	r15
   60728:	0f 93       	push	r16
   6072a:	1f 93       	push	r17
   6072c:	cf 93       	push	r28
   6072e:	df 93       	push	r29
   60730:	18 2f       	mov	r17, r24
   60732:	f9 2e       	mov	r15, r25
   60734:	c6 2f       	mov	r28, r22
   60736:	e0 ec       	ldi	r30, 0xC0	; 192
   60738:	f1 e0       	ldi	r31, 0x01	; 1
   6073a:	02 85       	ldd	r16, Z+10	; 0x0a
   6073c:	d1 df       	rcall	.-94     	; 0x606e0 <nvm_eeprom_flush_buffer>
   6073e:	e0 ec       	ldi	r30, 0xC0	; 192
   60740:	f1 e0       	ldi	r31, 0x01	; 1
   60742:	27 85       	ldd	r18, Z+15	; 0x0f
   60744:	22 23       	and	r18, r18
   60746:	ec f3       	brlt	.-6      	; 0x60742 <nvm_eeprom_write_byte+0x1c>
   60748:	6c 2f       	mov	r22, r28
   6074a:	81 2f       	mov	r24, r17
   6074c:	da df       	rcall	.-76     	; 0x60702 <nvm_eeprom_load_byte_to_buffer>
   6074e:	c0 ec       	ldi	r28, 0xC0	; 192
   60750:	d1 e0       	ldi	r29, 0x01	; 1
   60752:	1a 82       	std	Y+2, r1	; 0x02
   60754:	f9 82       	std	Y+1, r15	; 0x01
   60756:	18 83       	st	Y, r17
   60758:	85 e3       	ldi	r24, 0x35	; 53
   6075a:	8a 87       	std	Y+10, r24	; 0x0a
   6075c:	61 e0       	ldi	r22, 0x01	; 1
   6075e:	8b ec       	ldi	r24, 0xCB	; 203
   60760:	91 e0       	ldi	r25, 0x01	; 1
   60762:	5f dd       	rcall	.-1346   	; 0x60222 <ccp_write_io>
   60764:	0a 87       	std	Y+10, r16	; 0x0a
   60766:	df 91       	pop	r29
   60768:	cf 91       	pop	r28
   6076a:	1f 91       	pop	r17
   6076c:	0f 91       	pop	r16
   6076e:	ff 90       	pop	r15
   60770:	08 95       	ret

00060772 <nvm_eeprom_fill_buffer_with_value>:
   60772:	cf 93       	push	r28
   60774:	df 93       	push	r29
   60776:	d8 2f       	mov	r29, r24
   60778:	b3 df       	rcall	.-154    	; 0x606e0 <nvm_eeprom_flush_buffer>
   6077a:	e0 ec       	ldi	r30, 0xC0	; 192
   6077c:	f1 e0       	ldi	r31, 0x01	; 1
   6077e:	87 85       	ldd	r24, Z+15	; 0x0f
   60780:	88 23       	and	r24, r24
   60782:	ec f3       	brlt	.-6      	; 0x6077e <nvm_eeprom_fill_buffer_with_value+0xc>
   60784:	c0 e0       	ldi	r28, 0x00	; 0
   60786:	6d 2f       	mov	r22, r29
   60788:	8c 2f       	mov	r24, r28
   6078a:	bb df       	rcall	.-138    	; 0x60702 <nvm_eeprom_load_byte_to_buffer>
   6078c:	cf 5f       	subi	r28, 0xFF	; 255
   6078e:	c0 32       	cpi	r28, 0x20	; 32
   60790:	d1 f7       	brne	.-12     	; 0x60786 <nvm_eeprom_fill_buffer_with_value+0x14>
   60792:	df 91       	pop	r29
   60794:	cf 91       	pop	r28
   60796:	08 95       	ret

00060798 <nvm_eeprom_erase_bytes_in_all_pages>:
 *
 * This function erases bytes from all EEPROM pages, so that every location
 * written to in the page buffer reads 0xFF.
 */
void nvm_eeprom_erase_bytes_in_all_pages(void)
{
   60798:	1f 93       	push	r17
   6079a:	cf 93       	push	r28
   6079c:	df 93       	push	r29
   6079e:	e0 ec       	ldi	r30, 0xC0	; 192
   607a0:	f1 e0       	ldi	r31, 0x01	; 1
   607a2:	87 85       	ldd	r24, Z+15	; 0x0f
   607a4:	88 23       	and	r24, r24
   607a6:	ec f3       	brlt	.-6      	; 0x607a2 <nvm_eeprom_erase_bytes_in_all_pages+0xa>
 */
static inline void nvm_issue_command(NVM_CMD_t nvm_command)
{
	uint8_t old_cmd;

	old_cmd = NVM.CMD;
   607a8:	c0 ec       	ldi	r28, 0xC0	; 192
   607aa:	d1 e0       	ldi	r29, 0x01	; 1
   607ac:	1a 85       	ldd	r17, Y+10	; 0x0a
	NVM.CMD = nvm_command;
   607ae:	80 e3       	ldi	r24, 0x30	; 48
   607b0:	8a 87       	std	Y+10, r24	; 0x0a
	ccp_write_io((uint8_t *)&NVM.CTRLA, NVM_CMDEX_bm);
   607b2:	61 e0       	ldi	r22, 0x01	; 1
   607b4:	8b ec       	ldi	r24, 0xCB	; 203
   607b6:	91 e0       	ldi	r25, 0x01	; 1
   607b8:	34 dd       	rcall	.-1432   	; 0x60222 <ccp_write_io>
	NVM.CMD = old_cmd;
   607ba:	1a 87       	std	Y+10, r17	; 0x0a
	// Wait until NVM is ready
	nvm_wait_until_ready();

	// Issue EEPROM Erase All command
	nvm_issue_command(NVM_CMD_ERASE_EEPROM_gc);
}
   607bc:	df 91       	pop	r29
   607be:	cf 91       	pop	r28
   607c0:	1f 91       	pop	r17
   607c2:	08 95       	ret

000607c4 <nvm_eeprom_erase_all>:
 * This function erases the entire EEPROM memory block to 0xFF.
 */
void nvm_eeprom_erase_all(void)
{
	// Mark all addresses to be deleted
	nvm_eeprom_fill_buffer_with_value(0xff);
   607c4:	8f ef       	ldi	r24, 0xFF	; 255
   607c6:	d5 df       	rcall	.-86     	; 0x60772 <nvm_eeprom_fill_buffer_with_value>
	// Erase all pages
	nvm_eeprom_erase_bytes_in_all_pages();
   607c8:	e7 cf       	rjmp	.-50     	; 0x60798 <nvm_eeprom_erase_bytes_in_all_pages>
   607ca:	08 95       	ret

000607cc <initbootuart>:
*  As this is important function of initializing the UART, it has to be called prior to start the communication.
*
*/
void initbootuart(void)
{
   UART_PORT.DIRSET |= UART_TX_PIN;
   607cc:	e0 e6       	ldi	r30, 0x60	; 96
   607ce:	f6 e0       	ldi	r31, 0x06	; 6
   607d0:	81 81       	ldd	r24, Z+1	; 0x01
   607d2:	88 60       	ori	r24, 0x08	; 8
   607d4:	81 83       	std	Z+1, r24	; 0x01
   BAUD_RATE_LOW_REG = BRREG_VALUE;
   607d6:	e0 ea       	ldi	r30, 0xA0	; 160
   607d8:	f9 e0       	ldi	r31, 0x09	; 9
   607da:	8c e0       	ldi	r24, 0x0C	; 12
   607dc:	86 83       	std	Z+6, r24	; 0x06
   UART_CONTROL_REG = (1 << ENABLE_RECEIVER_BIT) |
   607de:	88 e1       	ldi	r24, 0x18	; 24
   607e0:	84 83       	std	Z+4, r24	; 0x04
   607e2:	08 95       	ret

000607e4 <sendchar>:
*  \param  c     Character value to be transmitted.
*
*/
void sendchar(unsigned char c)
{ 
   UART_DATA_REG = c; // prepare transmission
   607e4:	80 93 a0 09 	sts	0x09A0, r24
   while (!(UART_STATUS_REG & (1 << TRANSMIT_COMPLETE_BIT)));
   607e8:	e0 ea       	ldi	r30, 0xA0	; 160
   607ea:	f9 e0       	ldi	r31, 0x09	; 9
   607ec:	81 81       	ldd	r24, Z+1	; 0x01
   607ee:	86 ff       	sbrs	r24, 6
   607f0:	fd cf       	rjmp	.-6      	; 0x607ec <sendchar+0x8>
   // wait until byte sendt
   UART_STATUS_REG |= (1 << TRANSMIT_COMPLETE_BIT); // delete TXCflag
   607f2:	e0 ea       	ldi	r30, 0xA0	; 160
   607f4:	f9 e0       	ldi	r31, 0x09	; 9
   607f6:	81 81       	ldd	r24, Z+1	; 0x01
   607f8:	80 64       	ori	r24, 0x40	; 64
   607fa:	81 83       	std	Z+1, r24	; 0x01
   607fc:	08 95       	ret

000607fe <recchar>:
*/

unsigned char recchar(void)
{
   unsigned char ret;
   while(!(UART_STATUS_REG & (1 << RECEIVE_COMPLETE_BIT)));  // wait for data
   607fe:	e0 ea       	ldi	r30, 0xA0	; 160
   60800:	f9 e0       	ldi	r31, 0x09	; 9
   60802:	81 81       	ldd	r24, Z+1	; 0x01
   60804:	88 23       	and	r24, r24
   60806:	ec f7       	brge	.-6      	; 0x60802 <recchar+0x4>
   ret = UART_DATA_REG;
   60808:	80 91 a0 09 	lds	r24, 0x09A0
   return ret;
}
   6080c:	08 95       	ret

0006080e <_exit>:
   6080e:	f8 94       	cli

00060810 <__stop_program>:
   60810:	ff cf       	rjmp	.-2      	; 0x60810 <__stop_program>

Disassembly of section .BOOT:

00060812 <nvm_common_spm>:
	/**
	 * For GCC:
	 * \param address uint32_t r22:r25
	 * \param nvm_cmd uint8_t  r20
	 */
	in r25, RAMPZ         ; Store RAMPZ. Highest address byte is ignored, so using that
   60812:	9b b7       	in	r25, 0x3b	; 59
	out RAMPZ, r24        ; Load R24 into RAMPZ
   60814:	8b bf       	out	0x3b, r24	; 59
	movw ZL, r22          ; Load R22:R23 into Z.
   60816:	fb 01       	movw	r30, r22
	lds r24, NVM_CMD      ; Store NVM command register (r24 is no longer needed)
   60818:	80 91 ca 01 	lds	r24, 0x01CA
	sts NVM_CMD, r20      ; Load prepared command into NVM Command register.
   6081c:	40 93 ca 01 	sts	0x01CA, r20
	ldi r23, CCP_SPM_gc   ; Prepare Protect SPM signature (r23 is no longer needed)
   60820:	7d e9       	ldi	r23, 0x9D	; 157
	sts CCP, r23          ; Enable SPM operation (this disables interrupts for 4 cycles).
   60822:	70 93 34 00 	sts	0x0034, r23
	spm                   ; Self-program.
   60826:	e8 95       	spm
	sts NVM_CMD, r24      ; Restore NVM command register
   60828:	80 93 ca 01 	sts	0x01CA, r24
	out RAMPZ, r25        ; Restore RAMPZ register.
   6082c:	9b bf       	out	0x3b, r25	; 59
	spm                   ; Self-program.
	sts NVM_CMD, r18      ; Restore NVM command register
	out RAMPZ, r19        ; Restore RAMPZ register.
#endif

	ret
   6082e:	08 95       	ret

00060830 <nvm_flash_load_word_to_buffer>:
	 * For GCC:
	 * \param word_addr uint32_t r22:r25
	 * \param data      uint16_t r20:r21
	 */
wait_nvm:
	lds r18, NVM_STATUS
   60830:	20 91 cf 01 	lds	r18, 0x01CF
	sbrc r18, NVM_NVMBUSY_bp
   60834:	27 fd       	sbrc	r18, 7
	rjmp wait_nvm
   60836:	fc cf       	rjmp	.-8      	; 0x60830 <nvm_flash_load_word_to_buffer>

	in r25, RAMPZ         ; Store RAMPZ. Highest address byte is ignored, so using that
   60838:	9b b7       	in	r25, 0x3b	; 59
	out RAMPZ, r24        ; Load R24 into RAMPZ
   6083a:	8b bf       	out	0x3b, r24	; 59
	movw ZL, r22          ; Load R22:R23 into Z.
   6083c:	fb 01       	movw	r30, r22

	lds r24, NVM_CMD      ; Store NVM command register (r24 is no longer needed)
   6083e:	80 91 ca 01 	lds	r24, 0x01CA
	ldi r18, NVM_CMD_LOAD_FLASH_BUFFER_gc
   60842:	23 e2       	ldi	r18, 0x23	; 35
	sts NVM_CMD, r18      ; Load prepared command into NVM Command register.
   60844:	20 93 ca 01 	sts	0x01CA, r18

	movw r0, r20          ; Load R20:R21 into R0:R1
   60848:	0a 01       	movw	r0, r20
	spm                   ; Self-program.
   6084a:	e8 95       	spm

	clr r1                ; Clear R1 for GCC _zero_reg_ to function properly.
   6084c:	11 24       	eor	r1, r1
	sts NVM_CMD, r24      ; Restore NVM command register
   6084e:	80 93 ca 01 	sts	0x01CA, r24
	out RAMPZ, r25        ; Restore RAMPZ register.
   60852:	9b bf       	out	0x3b, r25	; 59

	sts NVM_CMD, r18      ; Restore NVM command register
	out RAMPZ, r19        ; Restore RAMPZ register.
#endif

	ret
   60854:	08 95       	ret
